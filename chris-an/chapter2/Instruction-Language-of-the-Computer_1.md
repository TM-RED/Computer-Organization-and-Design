# 2장. 명령어 : 컴퓨터 언어
명령어 표현 방식을 알면, 내장 프로그램 개념(stored-program concept)을 이해할 수 있다.

## 하드웨어 연산
기본적으로 모든 컴퓨터는 산술 연산을 할 수 있어야 한다.
```
add a, b, c
```
MIPS 산술 명령어는 반드시 한 종류의 연산만 지시하며 항상 변수 세 개를 갖는 형식을 엄격히 지킨다. <br>
<br>
### 설계 원칙 1: 간단하게 하기 위해서는 규칙적인 것이 좋다.
덧셈 같은 연산의 피연산자는 더해질 숫자 두개와 함꼐 기억할 저장소 하나, 모두 세 개인 것이 자연스럽다. 이렇게 모든 명령어가 피연산자를 반드시 세 개씩 갖도록 제한하는 것은 하드웨어를 단순하게 하자는 원칙과 부합하다. <br>
<br>
피연산자의 개수가 가변적이면 하드웨어가 복잡해진다.

> +) 자바는 이식성을 높이기 위해 소프트 웨어 인터프리터를 사용하도록 설계를 했다.<br>
> +) 이 인터프리터의 명령어 집합을 Java 바이트 코드라 부른다.<br>
> +) MIPS 명령어 집합과는 다른 점이 많다. <br>
> +) 자바는 C 언어보다 컴파일이 훨씬 늦게 일어난다. 그래서 비슷한 성능을 얻기 위해 Java 는 Java 바이트 코드를 기계어로 컴파일한다.<br>
> +) 그래서 Java 컴파일러를 JIT 라고 부르며 JIT 역할은 추후에 더 설명하겠다.

## 피연산자
MIPS 구조에서 레지스터의 크기는 32비트이다. <br>
MIPS 에서는 32비트가 한 덩어리로 처리되는 일이 매우 빈번하므로 이것을 워드(word)라고 알아두자.
<br>
산술 명령어의 각 피연산자는 32개의 32비트 레지스터 중 하나이어야 한다는 제약이 추가된다.<br>

### 설계 원칙 2: 작은 것이 빠르다.
레지스터 개수를 32개로 제한하는 이유는 레지스터가 많아지면, 전기 신호가 더 멀리까지 전달되어야 하므로 클럭 사이클 시간이 길어진다. <br>
즉 작은 것이 빠르다는 말을 하지만, 그래도 작은 것이 더 빠르다가 절대 적인 것은 아니다.<br>
<br>
또한, 또 다른 이유는 명령어 형식에서 레지스터가 사용하는 비트수와 관련이 있다.<br>

> *용어 정리* <br>
> 
> **데이터 전송 명령어** : MIPS 의 산술 연산은 레지스터에서만 실행되므로 메모리와 레지스터 간에 데이터를 주고 받는 명령어가 필요한데 그걸 데이터 전송 명령어라 한다. <br>
> 
> **적재** : 메모리에서 레지스터로 데이터를 복사해 오는 데이터 전송 명령어 (명렁어의 실제 이름은 lw) <br>
> 
> **병렬 제약** : MIPS 에서 워드의 시작 주소는 항상 4의 배수이어야 한다. 그 이유는 병렬을 사용하면 데이터 전송이 빨라진다. <br>
> 
> **저장** : 적재와 반대로 레지스터에서 메모리로 데이터를 보내는 명령 (명령어의 실제 이름은 sw) <br>

컴퓨터가 갖고 있는 레지스터보다 프로그램에서 사용하는 변수가 더 많은 경우가 자주 있다.<br>
<br>
그러므로 컴파일러는 자주 사용되는 변수를 가능한 한 많이 레지스터에 넣고 나머지 변수는 메모리에 저장했다가 필요할 때 꺼내서 레지스터에 넣는다. <br>
<br>
자주 사용하지 않는 변수를 메모리에 넣는 일을 레지스터 스필링이라고 한다.

> +) 작을 수록 빠르다는 원칙에 의하면 레지스터가 더 작으므로 메모리는 레지스터보다 속도가 느려야한다.<br>
> +) 이것이 사실이며 데이터가 레지스터에 있으면 더 빨리 접근할 수 있다. <br>
> +) 또한 레지스터에 저장된 데이터는 메모리 데이터보다 사용하기도 편하다.

메모리보다 레지스터가 좋은 점
- 메모리보다 접근시간이 짧다
- 처리량이 많다.
- 레지스터 접근은 메모리 접근보다 에너지도 적게 든다.

따라서, 컴파일러가 레지스터를 효율적으로 사용하여야 한다.

## 부호 있는 수와 부호 없는 수
컴퓨터 프로그램은 양수와 음수를 모두 계산한다. 따라서 구별하는 표현 방법이 필요하다. <br>
요약을 하면, 컴퓨터 워드에 양수와 음수를 모두 나타낼 필요성이 있는데, 그 방법이 여러가지 방식이 제안되어 왔지만, <br>
1965년 이후에는 2의 보수 표현법이 대세가 되었다. 

## 명령어의 컴퓨터 내부 표현
명령어 형식이라는 게 있다. 이진수의 필드로 구성된 명령어의 표현 형식이다. <br>
명령어의 길이는 데이터 워드와 마찬가지로 32비트이다. <br>
<br>
필드는 표기하기 쉽게 MIPS 명령어의 각 필드에 다음과 같은 이름이 붙어있다.

R타입.

| op            | rs     | rt     | rd     | shamt  | funct  |
|---------------|--------|--------|--------|--------|--------|
| 6 bits        | 5 bits | 5 bits | 5 bits | 5 bits | 6 bits |

- op : 명령어가 실행할 연산의 종류로서 연산자라고 부른다.
- rs : 첫 번째 근원지 피연산자 레지스터
- rt : 두 번째 근원지 피연산자 레지스터
- rd : 목적지 레지스터. 연산 결과가 기억 됨
- shamt : 자리이동량
- funct : 기능. op 필드에서 연산의 종류를 표시하고, funct 필드에서는 그 중의 한 연산을 구체적으로 지정한다. 기능 코드라고 부른다.

### 설계 원칙 3: 좋은 설계에는 적당한 절충이 필요하다.
이 명령어 형식보다도 필드가 길이가 더 길어야하는 경우에 문제가 생길 수 있다.<br>
필드의 비트 수가 작기 때문에 그보다 큰 값이 들어갈 경우, 문제가 발생된다.<br>
따라서, 모든 명령어의 길이를 같게 하고싶은 생각과 명령어 형식을 한 가지로 통일하고 싶은 생각이 든다. <br>
<br>
MIPS 설계자는 정충안으로, I 형식을 도입한다. <br>
I 형식은 수치 연산과 데이터 전송 명령어에서 사용된다.

| op            | rs     | rt     | constant or address |
|---------------|--------|--------|---------------------|
| 6 bits        | 5 bits | 5 bits | 16 bits             |

16비트 주소를 사용후므로 lw 명령은 베이스 레지스터 rs 에 저장된 조수를 기준으로 큰 워드를 지정할 수 있다.


> 모든 명령어의 길이를 같게 하려는 욕망과, 더 많은 레지스터를 가지려는 욕망이 충돌을 일으킨다. 레지스터 개수를 늘리게 되면 명령어 형식에서 각각의 레지스터 필드는 적어도 1비트가 필요한다. 하지만, 설계 원칙에 어긋나, 오늘날 대부분의 명령어 집합은 16개 또는 32개의 범용 레지스터를 갖고 있다.

## 논리 연산 명령어
초기의 컴퓨터는 워드 전체에 대한 처리에만 관심을 가졌으니, <br>
워드 내 일부 비트들에 대한 연산, 심지어는 개개 비트에 대한 연산도 필요하다는 것이 명백해졌다.<br>
<br>
워드 내에서 8비트로 저장된 문자를 검사하는 작업이 이러한 연산의 한 예다. <br>
<br>
뒤를 이어 비트들을 워드로 묶는 작업과 워드를 비트 단위로 나누는 작업을 간단하게 하는 명령어들이 프로그래밍 언어와 명령어 집합에 추가되었고, 이를 논리 연산 명령어라 한다.

## 판단을 위한 명령어
컴퓨터가 단순한 계산기와 다른 점은 판단 기능이 있다는 것이다.<br>
beq(branch if equal), bne(branch if not equal) 두 명령어가 존재하며, 조건부 분기라고 부른다.

- 순환문(while, for) 
- Case/Switch 문장 (if-then-else) : jr 이라는 명령어를 통해, 레지스터 에 명시된 주소로 무조건 점프한다.


MIPS 컴파일러는 slt, slti, beq, bne 와 레지스터 $zero 에 있는 상수 0을 이용해서 모든 비교 조건을 만들 수 있다. 
* slt, slti 는 대소 비교에 쓰이는 명령어.
> 하드웨어는 간단해야 좋다는 von Neumann 의 경고를 준수하여 MIPS 구조에서는 구현하기에 너무 복잡한 blt(branch one less then) 명령어를 제외시켰다. <br>
> 이 명령어를 구현하면 클럭 속도가 느려지거나 이 명령 실행에 별도의 클럭 사이클이 더 필요하게 된다. 그러므로 빠른 명령어 두 개를 사용하는 것이 더 유리하다.